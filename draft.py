# Арифметические операции в Python:
# a + b # сложение
# a - b # вычитание
# a * b # умножение
# a / b # деление
# a ** b # возведение a в степень b
# a // b # целая часть от деления a на b
# a % b # остаток от деления a на b

# Действие 22 // 7 выведет 3;
# действие 22 % 7 выведет 1;
# действие 10 // 3 выведет 3;
# действие 10 % 3 выведет 1.
# действие 3 % 2 выведет 1.5

# age = int(input("Введите ваш возраст: "))
# print("Через 10 лет вам будет", age + 10)
# если вы хотите вывести текст и какую-то переменную,
# после текста (после кавычек) перед переменной нужна запятая

# print(int("27"))
# print(int(27.5))
# И в первом, и во втором случае программа вывела 27
# v_engine = float(input("Введите объем двигателя: ")) выведет 1.8

# Все целые числа имеют тип данных int.
# Это такие числа, как 5, 25, 10, -788
# Все числа, у которых есть часть после точки, имеют тип данных float.
# Это такие числа, как 1.5, -133.7, 3.1415926 и т.п.

# \n – символ перехода на другую строку
# \t – символ табуляции
# \" – так можно поставить двойную кавычку
# \' – так можно поставить одинарную кавычку
# \\ – так можно поставить слэш
# \a – гудок встроенного в систему динамика

# print('раз\tдва\tтри\none\ttwo\tthree')
# раз два три
# one two three
# print('Маша\tКатя\tСаша\nMary\tKate\tAlex\nПривет/Hi!')

# У строк есть команды, которые помогают их преобразовывать.
# Эти команды не изменяют исходную строчку.
# Они генерируют новую строчку на основе старой,
# потому что строка — неизменяемый тип данных.
# То есть ее просто нельзя изменить.

# text = "не кричи на меня!"
# print(text.upper())
# В терминале пользователь увидит: НЕ КРИЧИ НА МЕНЯ!
# print(text)
# В терминале пользователь увидит: не кричи на меня!

# Что делать, если мы всё же хотим изменить текст?
# Для этого нужно перезаписать переменную text:
# text = "не кричи на меня!"
# text = text.upper()

# метод count() – считает, сколько символов в строке.
# Например, "aaabbb".count("a") вернёт число 3 —
# столько букв "a" на этой строке

# replace(подстрока, строка) – заменяет подстроку на строку, например
# "хочу спать".replace("спать", "есть") вернёт строчку "хочу есть"

# lower() – переведёт все символы в нижний регистр

# split(символ) – разобьет строку на элементы и вернёт список (тип данных)

# Строка — это упорядоченный тип данных, поэтому
# у каждого символа есть свой порядковый номер, индекс
# my_father = "Oleg Ivanovich"
# print(my_father[5])
# Так мы выведем символ нашей строки с индексом 5

# В Python можно брать не только отдельный символ, но и часть строки.
# Для этого используют срезы.
# song = "Ооо, зеленоглазое такси!"
# print(song[0:3]) # берем символы с самого 1-го до символа с индексом 2
# Под номером 3 стоит запятая, но она не будет включена в срез.
# Конец среза указывается не включительно

# Функция len() позволяет узнать длину строки. Например:
# print(len("на экране будет только длина этой строки"))
# В Python у строк большой выбор методов, синтаксис у всех один —
# название метода(строка).
# Узнать об остальных вы можете на этой странице: https://ps.readthedocs.io/.

# Конкатенация строк - это то, что следует за ковычками.
# Официальное руководство с правилами к написанию кода на Python: https://peps.python.org/

# Тип данных bool, или булевый/логический тип,
# ялвяется примитивным типом данных в информатике, программировании,
# он может принимать только два возможных значения — True и False
# Эти два значения всегда являются результатом операций условных операторов

# x > y
# x < y
# x == y # проверяет равенство значений
# x <= y
# x >= y
# x != y # не равен
# not x # не х
# x and y # х и у
# x or y # х или у
# x is y # сравнивает идентичность объектов
# x in y # х входит во множество у

# print("A" > "a") # False
# print("abc" > "cba") # False
# Строки сравниваются по ASCII-коду отдельных символов.
# Таким образом, "a" (97) в таблице ASCII стоит позже, чем "A" (65).
# Узнать код символа в таблице можно командой ord("x") —
# внутри поставьте нужный символ и не забудьте вывести результат.
# print(ord('A')) # 65

# Значения типа данных bool используются в условных конструкциях.
# Условные конструкции позволяют выполнять код внутри себя, если верно условие.
# Если условие не соблюдается, то код внутри не выполняется.
# age = int(input("Введите свой возраст: "))
# if age >= 18:
#    print("Продажа алкоголя – разрешена.")
#    print("Продажа акционных товаров – разрешена.")
# print("До встречи!")

# У условной конструкции могут быть дополнительные блоки else и/или elif.
# if условие1:
#    действие 1
# else:
#    действие 2

# if условие1:
#    действие1
# elif условие2:
#    действие2
# elif условие3:
#    действие3
# else:
#    действие4

# Блок else срабатывает тогда, когда ни один из блоков условной конструкции
# не выполнился до него.

# Блок elif выполняется тогда, когда не выполнился if или elif до него.

# Тернарный, он же условный, оператор — это способ назначать значения
# без нагромождений отдельных условных конструкций.
# choice = input("кетчуп или майонез: ")
# price = 10 if choice == "кетчуп" else 12
# print(price)

# day = input('введите день Вашего рождения: ')
# text = 'С Днем Рождения!' if day == '29.01.2024' else 'Благодарю за информацию!'
# print(text)

# my_first_list = ["это", "элементы", "списка"]
# empty_list = [] # пустой список
# empty_list = list() # такой же пустой список
# multi_list = [1337, "wow", [True, 32.5], [4, 20], "word"]
# Списки могут хранить в себе объекты разных типов данных
# Списки могут хранить внутри себя другие списки

# С помощью индексов можно менять содержимое списка
# little_list = ["first", "second", "third"]
# Заменим элемент "first" с индексом 0 на элемент "первый", а "second" на "второй":
# little_list[0] = "первый"
# little_list[1] = "второй"

# Строка — неизменяемый тип.
# Когда мы обращались к символу строки по индексу, мы его не меняли.
# Список — изменяемый тип. В нем содержимое можно менять.

# my_darling_list = []
# my_darling_list.append(100)
# my_darling_list.append(200)
# print(my_darling_list) # [100, 200]
# метод append добавил элементы в текущий список
# о методах списков https://inlnk.ru/jE62JR

# и pop и remove оба удаляют элемент списка.
# Pop вырезает элемент, остается возможность куда-нибудь его подставить.
# Remove — просто удаляет элемент списка

# метод append добавляет элемент в конец списка
# метод sort сортирует элементы списка по возрастанию

# my_darling_list = [100, 200]
# my_darling_list.insert(0, 300) # index: 0, object: 300
# print(my_darling_list) # [300, 100, 200]
# my_darling_list.sort()
# print(my_darling_list) # [100, 200, 300]

# Тип данных tuple, или кортеж, тоже является коллекцией,
# т.е. может хранить в себе множество элементов.
# Его отличие от списков в том, что tuple не изменяем,
# поэтому не имеет множества методов, которые есть у списка.

# my_first_tuple = ("first", "second", "third")
# print(my_first_tuple[0]) # first
# Но если мы попробуем изменить его, интерпретатор Python выдаст ошибку:
# my_first_tuple[0] = "первый" # Ошибка

# Преимущество кортежей перед списками в том, что
# кортежи занимают меньше места в оперативной памяти и
# позволяют уберечь значения от изменений

# Кортежи имеют два метода count и index.
# метод count позволяет узнать количество определенного элемента в кортеже, а
# метод index позволяет узнать позицию элемента в кортеже.
# Если таких элементов несколько, то он выводит номер первого вхождения.

# Тип данных set, или множество, тоже является контейнером для хранения объектов.
# Отличие set (множества) в том, что он хранит только уникальные объекты.
# Множество — это неупорядоченная коллекция,
# порядок элементов в нем всегда случайный.

# a = {1, 2, 2, 3, 3, 4, 4} # множество
# print(a) # {1, 2, 3, 4}

# В некоторых операциях множества могут быть в разы быстрее списков.
# Дополнительная информация о контейнерах Python. https://habr.com/ru/

# Тип данных dict, или словарь, является контейнером.
# Его отличие в том, что он хранит данные в виде ключ:значение (key:value).
# Ключом может выступать число или строка.
# Значением может быть любой объект в Python.

# my_first_dict = {'1й день':'ПН', '2й день':'ЧТ', 3:'СР'}
# print(my_first_dict['1й день']) # ПН
# Обращаться к значению из словаря можно через ключ

# haracter = {"name": "Kaguya ",
# "lastname": "Shinomiya", # словарь можно переносить для удобства
# "age": 17,
# "description": "Kaguya was a very cold"} # словарь закрыт
# print(haracter["name"]) # Kaguya
# print(haracter["description"]) # Kaguya was a very cold

# Словари незаменимы для работы с API сайтов.
# Этот формат хранения данных напоминает объекты из javascript и
# запись JSON. Python имеет отдельный модуль
# для преобразования объектов из JSON в словари Python.

# dict.items() — возвращает пары (ключ, значение)
# dict.keys() — возвращает ключи в словаре
# dict.values() — возвращает значения в словаре
# dict.clear() — очищает словарь
# dict.copy() — возвращает копию словаря
# dict.get(key[, default]) — возвращает значение ключа, но если его нет,
# не бросает исключение, а возвращает default (по умолчанию None)
# dict.pop(key[, default]) — удаляет ключ и возвращает значение;
# если ключа нет, возвращает default (по умолчанию бросает исключение)
# dict.popitem() — удаляет и возвращает пару (ключ, значение);
# если словарь пуст, бросает исключение KeyError.
# Помните, что словари не упорядочены.
# dict.setdefault(key[, default]) — возвращает значение ключа,
# но если его нет, не бросает исключение, а создает ключ со значением
# default (по умолчанию None)
# dict.update([other]) — обновляет словарь, добавляя пары (ключ, значение)
# из other. Существующие ключи перезаписываются.
# Возвращает None (не новый словарь)

# Наиболее применимы методы items(), keys(), values().

# В цикле While код будет выполняться до тех пор, пока условие правдиво
# В условной конструкции if если условие правдиво, код выполнится.
# Для досрочного завершения цикла используется оператор break.
# while True:
#    print("Это сработает")
#    break
#    print("Это не сработает")
# print("И это сработает")

# Если оставить любую управляющую конструкцию пустой,
# то Python интерпретатор будет выдавать ошибку
# Если вы делаете наброски в коде и пока не хотите
# реализовывать конструкцию, используйте оператор pass.
# Не забудьте убрать его, когда будете дописывать конструкцию
# while True:
#     pass

# choice = input("Input yes/no: ")
# while choice != "yes":
#    choice = input("Input yes/no: ")
# print("Well done!")

# random_names = ["Peter", "Ivan", "Mark", "Maksim", "Alex", "Jacob", "Abdula", "John", "Sinji"]
# i = 0
# length = len(random_names)
# while i < length: # пока переменная i меньше длины списка
#     print(random_names[i]) # выводит список в столбик по словам (по элементам
#     i += 1 # тоже самое, что i=i+1
# Или то же самое через for
# random_names = ["Peter", "Ivan", "Mark", "Maksim", "Alex", "Jacob", "Abdula", "John", "Sinji"]
# for name in random_names:
#    print(name)

# random_names = ["Peter", "Ivan", "Mark", "Maksim", "Alex", "Jacob", "Abdula", "John", "Sinji"]
# for name in random_names:
#    name = "Qwerty" # В переменной цикла хранится продублированное значение
#    print(name) # вывод Qwerty
# print(random_names) # элемент в коллекции не меняется

# random_names = ["Peter", "Ivan", "Mark", "Alex", "Maksim", "Jacob", "Abdula", "John", "Sinji"]
# m_names = [] # пустой список
# for name in random_names: # здесь name - это элемент списка: Peter, Mark
#    if name[0] == "M": # если в элементе 1 буква М, то:
#        m_names.append(name) : добавляем элемент Mark в пустой список
# print(m_names)

# Второй вариант — это использовать enumerate
# Эта команда возвращает коллекцию, в которой
# каждый отдельный элемент имеет вид (номер_элемента, элемент).
# И чтобы получить номер и сам элемент используют распаковку.
# Сперва указываем номер i и через запятую имя переменной,
# в которую будут подставляться элементы коллекции:
# random_names = ["Peter", "Ivan", "Mark", "Alex", "Maksim", "Jacob", "Abdula", "John", "Sinji"]
# for i,name in enumerate(random_names):
#    if name[0] == "M":
#        random_names.pop(i)
# print(random_names)

# range(start, stop, step). # точка старта и шаг являются необязательными значениями
# range(10) # от 0 до 9
# range(0, 10) # от 0 до 9
# range(0, 10, 1) # от 0 до 9
# print(range(0,10,1)) # выведет: range(0, 10)
# Range не хранит числа в памяти.
# Когда требуется получить доступ к какому-то элементу
# из последовательности, интерпретатор вычисляет его.
# Список, в котором записаны все числа от 0 до 100000,
# занимает 800056 байт. Диапазон range занимает всего лишь 48 байт.
# Компьютеру, в данном случае, проще вычислить значения, чем их хранить.

# from sys import getsizeof # этот модуль позволяет размер определенного элемента
# print(getsizeof(range(100000))) # узнаём размер range(100000)
# print(getsizeof(list(range(100000)))) # узнаём размер списка, состоящего из диапазона чисел

# Очень распространено ошибочное заблуждение, что range является функцией.
# На самом деле range — это тип данных, который представляет собой
# неизменяемую последовательность чисел
# Обращаться к определенному элементу диапазона можно так же,
# как и к элементу списка — по индексу
# a = range(1000)
# print(a[0]) # выведет 0
# print(a[1]) # выведет 1
# print(a[1000]) # выведет ошибку

# for i in range(10): # цикл работает 10 раз,
#    print(i) # i принимает значение от 0 до 9

# s = 0 # сюда будем складывать сумму квадратов
# for i in range(1, 10): # запускаем последовательность чисел от 1 до 10
#    s += i**2 # суммируем квадраты значений
# print(s)

# Функции встроенные в Python, например sum
# numbers = [65, 111, 1000, 7]
# s = sum(numbers)
# print(s)

# Другой вариант - создать функцию самому:
# def custom_sum(): # определяем инструкцию def и называем функцию
#     numbers = [65, 23, 111, 1000, 7]
#     s = 0
#     for n in numbers:
#         s += n
#         print(s)
# custom_sum() # вызываем функцию, что бы она сработала, если убрать - результата не будет

# def say_hello():
#    print('Привет,', imya, '!:)')
# imya = input('Как вас зовут? ')
# say_hello()

# def mail_innformation():
#    print('На Вашу почту', mail_adress, 'будет направлено письмо')
# mail_adress = input('Введите адрес Вашей почты: ')
# mail_innformation()

# def custom_sum(numbers): # создаем функцию для универсального списка
#    s = 0
#    for n in numbers:
#        s += n
#    print(s)
# custom_sum([10, 20, 20]) # передаем любой список при вызове функции
# в противном случае, если список не передать, будет ошибка

# def custom_sum(nums): # Удалён вывод внутри функции
#    s = 0
#    for n in nums:
#        s += n
#    return s # Оператор return возвращает ответ
# result = custom_sum([65, 23, 111, 1000, 7]) # Добавлена переменная
#  result, в которой хранится результат работы функции
# print(result)

# print(print()) # функция print() возвращает None - значение пустоты
# оператор return возвращает значение из функции.

# def get_socks():
#    left_sock = "Левый"
#    right_sock = "Правый"
#    return (left_sock, right_sock)
# left_sock, right_sock = get_socks() # этот прием называется распаковка
# print(get_socks())

# Пример распаковки
# fruits = ["apple", "banana"]
# apple, banana = fruits
# print(apple)
# print(banana)

# def something(a, b, c=10): # c - это стандартное значение, если при
# вызове функции не укажем третью позицию, то будет 10, укажем - так как введем
#   print(c)
# something(0, 0, 7) # вывод 7
# something(0, 0) # вывод 10 (по умолчанию)

# Если вы хотите обрабатывать неопределенное количество аргументов
# используйте *
# def something(*fruits):
#    for fruit in fruits:
#        print(fruit)
# something("apple", "banana", "orange", "pear")
# something("apple")

# Подсказки типа type hinting делают ваш код чище, красивее и понятнее
# def get_sum(a: int, b: int) -> int: # a и b — переменные типа integer
# Стрелка -> указывает на то, что возвращает функция

# Официальная документация по подсказкам в Python https://docs.python.org/

# n = 4
# for i in range(n): # равносильно инструкции for i in 0, 1, 2, 3,
#     # здесь выполняются повторяющиеся действия
# цикл завершен, т.к. закончился блок с отступами
# print('конец цикла')

# Если нужно создать список по определенному правилу, используем
# генераторы списков
# nums = [1000, 237,146, 90, 6] # заданный список
# b = [num-7 for num in nums] # формируем новый список, если нам нужно
# вычесть 7 из всех элементов списка. Мы берем из списка nums элементы
# и называем их num. Далее из num вычитаем 7.
# print(b)

# Генераторы и генераторы списков — разные вещ
# nums = [1000, 237,146, 90, 6]
# a = [num-7 for num in nums] # это генератор списка
# b = (num-7 for num in nums) # а здесь просто генератор
# print(a) # [993, 230, 139, 83, -1]
# print(b) # <generator object <genexpr> at 0x00000263B52736B0>
# print(next(b)) # Чтобы узнать следующее значение нужно использовать функцию next()
# Главное отличие генератора от генератора списка в том, что
# генератор не хранит данные в "готовом виде", он вычисляет их
# по необходимости. Генератор работает только в одном направлении — вперед.

# Дополнительная информация про генераторы: https://pythoner.name/list-generator

#  Объектно-ориентированным программированием (ООП)
# ссылка 1: https://pythonworld.ru/;
# ссылка 2: https://pythonworld.ru/.

# Про функциональную парадигму здесь: https://tproger.ru/

# Называть классы принято в стиле CamelCase — слитно, начало слов с заглавной буквы
# class Dog:
#    age = 0
#    name = ""
# mumu = Dog()
# mumu.age = 2
# mumu.name = "Муму"
# выведем переменные на экран
# print(mumu.age)
# print(mumu.name)
# По этому "чертежу", нашему классу, мы можем создать
# неограниченное количество объектов, которые будут содержать
# свои значения
# goofy = Dog()
# sharik = Dog()
# hatiko = Dog()
# goofy.name = "Goofy"
# sharik.name = "Шарик"
# hatiko.name = "ハチ公"
# Переменные, объявленные в классе Dog, не имеют отношения к
# переменным отдельных собак

var = 0
if var > 0:
    print('var > 0')
elif:
    print('var <= 0')
